<?php
/*  1.https://www.youtube.com/watch?v=kyDE63z2n4o */
В PHP у вас не может быть два класса, названных одинаково, все они должны быть уникальны. 
Проблема этого ограничения в том, что если вы используете чью-либо стороннюю библиотеку, 
предоставляющую класс с именем User, то вы не можете создать свой собственный класс, также названный User. 
Это по настоящему скверно, ведь User — очень удобно имя для класса, не так ли?

Пространства имен позволяют нам обойти эту проблему, и мы можем создать столько классов User, 
сколько нам понадобится.Кроме того пространства имен позволят нам организовать код в удобные пакеты, а также обозначить свои права владения этим кодом.

Давайте взглянем на самый обычный класс. 
Да… я знаю, что вы уже использовали их, при чем здесь пространства имен? Просто доверьтесь мне в этом, ок?
Создадим еще один класс по соседству с первым:



namespace Model;

// app/model/user.php

class User
{

}
Мы видим, класс с тем же названием, но есть одно отличие - мы добавили директиву namespace. Строка namespace Model указывает на то, что весь код этого файла относится к пространству имен Model. То есть все классы, описанные в этом файле, будут принадлежать этому пространству.

Теперь, снова используем класс User.



$user = new User();
Мы получим экземпляр первого класса. А вот таким образом можно создать объект класса из нужного нам пространства имен:



$user = new Model\User();
То есть достаточно указать название пространства в виде приставки к классу через разделитель \. Теперь мы получили экземпляр класса User из пространства имен Model. Довольно просто, не так ли?

Глубина вложенности пространств практически неограниченна. Например:
This\Namespace\And\Class\Combination\Is\Silly\But\Works



/*2. https://www.youtube.com/watch?v=lmKIdQECYyc */
Composer - менеджер зависимостей для PHP (Dependency Manager for PHP) или пакетный менеджер 
(зависимости это пакеты - логически законченные сторонние или собственные наработки, использующиеся в проекте).
Все зависимости composer хранит в файле composer.json.
Создать этот файл можно командой composer init.
Делается это командой create-project ("Create new project from a package into given directory.") в папке, 
где хотите создать папку проекта.
Например возьмём пакет продвинутой заготовки для приложения на yii2 
(https://packagist.org/packages/yiisoft/yii2-app-advanced). Значит этот пакет загрузили на packagist.org.

Командой composer update(Updates your dependencies to the latest version according to composer.json, and updates the composer.lock file.)
 – обновляет все установленные (или установит заново случайно удалённые) пакеты до свежих версий. 
 А может и не обновлять версии до самых свежих, если создать специальный composer.lock файл 
 — это позволяет зафиксировать комбинацию из стабильных версий всех используемых в проекте библиотек

 /* 3. https://www.youtube.com/watch?v=cEGY5C1NFuk */
 Создадим тег первой версии
git tag v1
Теперь текущая версия страницы называется v1.


Давайте создадим тег для версии, которая идет перед текущей версией и назовем его v1-beta.
 В первую очередь нам надо переключиться на предыдущую версию. 
 Вместо поиска до хэш, мы будем использовать ^, обозначающее «родитель v1».

Если обозначение v1^ вызывает у вас какие-то проблемы, попробуйте также v1~1, 
указывающее на ту же версию. Это обозначение можно определить как «первую версию предшествующую v1».

Выполняем:
git checkout v1^
cat hello.html
РЕЗУЛЬТАТ:
$ git checkout v1^
Note: checking out 'v1^'.
/*4. https://www.youtube.com/watch?v=f2NsfaGw3FM */
В любой момент вам может потребоваться что-либо отменить. Здесь мы рассмотрим несколько основных способов отмены сделанных изменений. Будьте осторожны, не все операции отмены в свою очередь можно отменить! Это одна из редких областей Git, где неверными действиями можно необратимо удалить результаты своей работы.

Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит, можно запустить commit с параметром --amend (дополнить):

$ git commit --amend
Эта команда использует для дополнения коммита вашу область подготовки (индекс). Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а изменится лишь комментарий к коммиту.

Запустится тот же редактор комментария к коммиту, но уже с комментарием к предыдущему коммиту. Комментарий можно отредактировать точно так же, как обычно, просто он заменит собой предыдущий.

Например, если вы фиксируете изменения, и понимаете, что забыли проиндексировать изменения в файле, который хотели включить в коммит, можно сделать примерно так:

$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
В итоге получится единый коммит — второй коммит заменит результаты первого.

/*5. https://www.youtube.com/watch?v=m9cXUN3YYXw */
Проект часто создает файлы которые вы не хотите отслеживать с помощью git. Это обычно включает файлы генерируемые процессом сборки или временные файлы созданные вашим редактором. Конечно, понятие неотслеживаемые файлы git-ом означает что они не будут обрабатываться при выполнении git add. Но это быстро начинает раздражать, когда вокруг лежат неотслеживаемые файлы; например они делают git add . и  git commit -a практически бесполезными, и они могут содержаться в выводе команды "git status".

Вы можете указать git игнорировать определенные файлы создав файл .gitignore на самом верхнем уровне рабочей директории, добавив в его содержимое что то вроде:

# Lines starting with '#' are considered comments.
# Ignore any file named foo.txt.
foo.txt
# Ignore (generated) html files,
*.html
# except foo.html which is maintained by hand.
!foo.html
# Ignore objects and archives.
*.[oa]
Просмотрите gitignore для детального объяснения синтаксиса. Вы можете также расположить .gitignore файлы в другой директории в вашем рабочем дереве, и их правила будут распространяться только на эти директории и их поддиректории. Файлы .gitignore как и любые другие файлы могут быть добавлены в репозиторий (выполните  git add .gitignore и git commit как обычно), что удобно когда исключающие паттерны (такие как паттерны сравненивающие выходные файлы сборки)имеют смысл для других пользователей, которые склонируют ваш репозиторий.

Если вы хотите чтобы исключающие паттерны действовали только на определенные репозитории (вместо каждого репозитория для заданного проекта), то вы возможно положите их в файл в вашем репозитории под именем .git/info/exclude, или в любой файл определенный переменной настройки core.excludesfile. Некоторые команды git могут также брать исключающие шаблоны прямо из командной строки. Просмотрите gitignore для получения подробностей.
/*6. https://www.youtube.com/watch?v=vfvvejoQRFQ */
Давайте рассмотрим ветвление и слияние на простом примере с таким процессом работы, который вы могли бы использовать в настоящей разработке. Мы выполним следующие шаги:

Поработаем над веб-сайтом.
Создадим ветку для работы над новой задачей.
Выполним некоторую работу на этой ветке.
На этом этапе вам поступит звонок о том, что сейчас критична другая проблема, и её надо срочно решить. Мы сделаем следующее:

Вернёмся на ветку для версии в производстве.
Создадим ветку для исправления ошибки.
После тестирования ветки с исправлением сольём её обратно и отправим в продакшн.
Вернёмся к своей исходной задаче и продолжим работать над ней.
Основы ветвления
Для начала представим, что вы работаете над своим проектом и уже имеете пару коммитов (см. рис. 3-10).



Рисунок 3-10. Короткая и простая история коммитов.
Вы решили, что вы будете работать над проблемой №53 из системы отслеживания ошибок, используемой вашей компанией. Разумеется, Git не привязан к какой-то определенной системе отслеживания ошибок. Так как проблема №53 является обособленной задачей, над которой вы собираетесь работать, мы создадим новую ветку и будем работать на ней. Чтобы создать ветку и сразу же перейти на неё, вы можете выполнить команду git checkout с ключом -b:

$ git checkout -b iss53
Switched to a new branch "iss53"
Это сокращение для:

$ git branch iss53
$ git checkout iss53
Рисунок 3-11 демонстрирует результат.



Рисунок 3-11. Создание новой ветки / указателя.
Во время работы над своим веб-сайтом вы делаете несколько коммитов. Эти действия сдвигают ветку iss53 вперёд потому, что вы на неё перешли (то есть ваш HEAD указывает на неё; см. рис. 3-12):

$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'


Рисунок 3-12. Ветка iss53 передвинулась вперёд во время работы.
Теперь вы получаете звонок о том, что есть проблема с веб-сайтом, которую необходимо немедленно устранить. С Git вам нет нужды делать исправления для неё поверх тех изменений, которые вы уже сделали в iss53, и нет необходимости прикладывать много усилий для отмены этих изменений перед тем, как вы сможете начать работать над решением срочной проблемы. Всё, что вам нужно сделать, это перейти на ветку master.

Однако, прежде чем сделать это, учтите, что если в вашем рабочем каталоге или индексе имеются незафиксированные изменения, которые конфликтуют с веткой, на которую вы переходите, Git не позволит переключить ветки. Лучше всего при переключении веток иметь чистое рабочее состояние. Существует несколько способов добиться этого (а именно, прятанье (stash) работы и правка (amend) коммита), которые мы рассмотрим позже. А на данный момент представим, что все изменения были добавлены в коммит, и теперь вы можете переключиться обратно на ветку master:

$ git checkout master
Switched to branch "master"
Теперь рабочий каталог проекта находится точно в таком же состоянии, что и в момент начала работы над проблемой №53, так что вы можете сконцентрироваться на исправлении срочной проблемы. Очень важно запомнить: Git возвращает ваш рабочий каталог к снимку состояния того коммита, на который указывает ветка, на которую вы переходите. Он добавляет, удаляет и изменяет файлы автоматически, чтобы гарантировать, что состояние вашей рабочей копии идентично последнему коммиту на ветке.

?>